"""GPX generation from ORS GeoJSON route data stored in GCS."""

import json
from typing import List, Tuple


def find_route_path(bucket_name: str, route_id: int, prefix: str = "all_routes/") -> str:
    """
    Find the GCS path for a route by its ID.

    Args:
        bucket_name: Name of the GCS bucket
        route_id: Route ID to search for
        prefix: GCS prefix to search in (default: "all_routes/")

    Returns:
        Full path to the route JSON file in GCS

    Raises:
        FileNotFoundError: If no matching route found
    """
    # Lazy import to avoid loading GCS client during module import
    from google.cloud import storage

    client = storage.Client()
    bucket = client.bucket(bucket_name)
    search_pattern = f"route_{route_id}.json"

    matches = [
        blob.name
        for blob in client.list_blobs(bucket, prefix=prefix)
        if blob.name.endswith(search_pattern)
    ]

    if not matches:
        raise FileNotFoundError(
            f"No file ending with {search_pattern} found in {prefix}"
        )

    if len(matches) > 1:
        # Multiple regions have this route - use first one
        print(f"⚠️ Multiple files found for route {route_id}: {matches}")
        print(f"Using: {matches[0]}")

    return matches[0]


def load_route_json_from_gcs(bucket: str, path: str, token: str = "google_default") -> dict:
    """
    Load a JSON file from GCS as a Python dict using fsspec.

    Args:
        bucket: GCS bucket name
        path: Path to JSON file within bucket
        token: GCS authentication token

    Returns:
        Route GeoJSON dict
    """
    # Lazy import to avoid loading fsspec during module import
    import fsspec

    uri = f"gs://{bucket}/{path}"
    fs = fsspec.filesystem("gcs", token=token)
    with fs.open(uri, "rb") as f:
        return json.load(f)


def extract_coords(route_json: dict) -> Tuple[List[Tuple[float, float]], List[float]]:
    """
    Extract (lat, lon) pairs and elevation data from GeoJSON route dict.

    Returns:
        Tuple of (coords, elevations) where coords is list of (lat, lon)
    """
    # ORS GeoJSON: FeatureCollection -> first feature -> geometry
    if route_json.get("type") == "FeatureCollection":
        features = route_json.get("features", [])
        if not features:
            raise ValueError("No features found in route JSON")
        geom = features[0].get("geometry", {})
    else:
        geom = route_json.get("geometry", {})

    gtype = geom.get("type")
    coords = geom.get("coordinates", [])

    coord_list = []
    elev_list = []

    if gtype == "LineString":
        # coords is list of [lon, lat, elev] triplets
        for lon, lat, elev in coords:
            coord_list.append((lat, lon))
            elev_list.append(elev)
    elif gtype == "MultiLineString":
        for line in coords:
            for lon, lat, elev in line:
                coord_list.append((lat, lon))
                elev_list.append(elev)
    else:
        raise ValueError(f"Unsupported geometry type: {gtype}")

    return coord_list, elev_list


def create_gpx_from_coords(
    coords: List[Tuple[float, float]],
    elevations: List[float],
    route_name: str = "Cycling Route",
    route_description: str = "Generated by CycleMore"
):
    """Create a GPX object from coordinate and elevation data."""
    # Lazy import to avoid loading gpxpy during module import
    import gpxpy
    import gpxpy.gpx

    if len(coords) != len(elevations):
        raise ValueError(
            f"Coords ({len(coords)}) and elevations ({len(elevations)}) must match"
        )

    # Create GPX object
    gpx = gpxpy.gpx.GPX()
    gpx.name = route_name
    gpx.description = route_description

    # Create track
    gpx_track = gpxpy.gpx.GPXTrack()
    gpx_track.name = route_name
    gpx.tracks.append(gpx_track)

    # Create segment
    gpx_segment = gpxpy.gpx.GPXTrackSegment()
    gpx_track.segments.append(gpx_segment)

    # Add points
    for (lat, lon), elev in zip(coords, elevations):
        gpx_segment.points.append(
            gpxpy.gpx.GPXTrackPoint(latitude=lat, longitude=lon, elevation=elev)
        )

    return gpx


def generate_gpx_for_route(
    route_id: int,
    route_name: str,
    bucket: str = "cycle_more_bucket",
    prefix: str = "all_routes/"
) -> str:
    """
    Generate GPX XML string for a route ID from GCS.

    Args:
        route_id: Route ID to generate GPX for
        route_name: Name to use in GPX file
        bucket: GCS bucket name (default: "cycle_more_bucket")
        prefix: GCS folder prefix (default: "all_routes/")

    Returns:
        GPX XML string ready to download

    Raises:
        FileNotFoundError: If route not found in GCS
        ValueError: If route JSON is malformed
    """
    # Find route in GCS
    path = find_route_path(bucket, route_id, prefix)

    # Load route data
    route_json = load_route_json_from_gcs(bucket, path)

    # Extract coordinates
    coords, elevations = extract_coords(route_json)

    # Generate GPX
    gpx = create_gpx_from_coords(
        coords=coords,
        elevations=elevations,
        route_name=route_name,
        route_description=f"CycleMore recommended route (ID: {route_id})"
    )

    return gpx.to_xml()
